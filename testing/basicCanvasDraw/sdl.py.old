import socket
import threading
import time
import numpy as np
import math
from PIL import Image

HOST = '127.0.0.1'
FRAME_PORT = 6000
BACKCHANNEL_PORT = 6001

WIDTH, HEIGHT = 64, 64

FRAME = np.random.randint(0, 256, (HEIGHT, WIDTH, 3), dtype=np.uint8)

t = 0.0
stop_event = threading.Event()  # Event to signal threads to stop
LASTEVENT = None  # Variable to store the last event for debugging  
def get_event():
    global LASTEVENT
    return LASTEVENT
def clear_event():
    global LASTEVENT
    LASTEVENT = None


def render_animated_gradient():
    global t
    frame = np.zeros((WIDTH, HEIGHT, 3), dtype=np.uint8)
    height, width, _ = frame.shape  # Correctly extract height (Y) and width (X)

    # Use NumPy's vectorised operations to calculate the gradient
    x = np.arange(width)  # Array of x-coordinates (horizontal axis)
    y = np.arange(height)[:, None]  # Array of y-coordinates (vertical axis, as a column vector)

    # Calculate the gradient for each colour channel
    frame[:, :, 0] = (x + t) % 256  # Red channel changes with x (horizontal) and frame
    frame[:, :, 1] = (y + t) % 256  # Green channel changes with y (vertical) and frame
    frame[:, :, 2] = (x + y + t) % 256  # Blue channel changes with x, y, and frame
    t += 0.1  # Increment time for animation effect
    return frame


def generate_frameOLD(width, height, t):
    frame = np.zeros((height, width, 3), dtype=np.uint8)
    for y in range(height):
        for x in range(width):
            r = int(127 * (1 + math.sin(x * 0.1 + t)))
            g = int(127 * (1 + math.sin(y * 0.1 + t)))
            b = int(127 * (1 + math.sin((x + y) * 0.05 + t)))
            frame[y, x] = (r, g, b)
    return frame, t + 0.1


def generate_frame():
    # Random RGB frame for testing
    data = np.random.randint(0, 256, (HEIGHT, WIDTH, 3), dtype=np.uint8)
    return data

def send_frame(frame):
    global FRAME
    FRAME = frame

def send_frames():
    global t, FRAME, WIDTH, HEIGHT
    while not stop_event.is_set():
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(5)  # Longer timeout for initial connection
                s.connect((HOST, FRAME_PORT))
                print("üü¢ Connected to C# frame receiver")
                
                # Optimize socket options for better performance
                s.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                s.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 1024 * 1024)  # 1MB send buffer

                frame_count = 0
                last_frame_data = None
                
                while not stop_event.is_set():
                    try:
                        frame = FRAME
                        
                        # Skip if frame hasn't changed (basic optimization)
                        if last_frame_data is not None and np.array_equal(frame, last_frame_data):
                            time.sleep(1 / 30)  # Faster polling when no change
                            continue
                        
                        last_frame_data = frame.copy()
                        
                        # Get frame dimensions
                        if len(frame.shape) == 3:
                            actual_width, actual_height, channels = frame.shape
                        else:
                            print(f"üî¥ Invalid frame shape: {frame.shape}")
                            continue
                        
                        # Debug info less frequently
                        if frame_count % 300 == 0:  # Every 30 seconds at 10fps
                            print(f"üîç Frame {frame_count} - {actual_width}x{actual_height}, Mean: {frame.mean():.1f}")
                        
                        # More efficient frame preparation
                        frame_transposed = np.transpose(frame, (1, 0, 2))
                        frame_contiguous = np.ascontiguousarray(frame_transposed, dtype=np.uint8)
                        frame_bytes = frame_contiguous.tobytes()
                        
                        # Send frame size and data together to reduce TCP overhead
                        size_msg = f"frameSize {actual_height} {actual_width}\n"
                        size_bytes = size_msg.encode('utf-8')
                        
                        # Combine header and data into single send operation
                        full_message = size_bytes + frame_bytes
                        s.sendall(full_message)
                        
                        frame_count += 1
                        time.sleep(1 / 15)  # Increase to 15 FPS for better performance
                        
                    except socket.error as e:
                        print(f"üî¥ Socket error during frame send: {e}")
                        break
                    except Exception as e:
                        print(f"üî¥ Error preparing frame: {e}")
                        continue
                        
        except (socket.timeout, ConnectionRefusedError) as e:
            if stop_event.is_set():
                break
            print(f"üî¥ Frame sender connection error: {e}. Retrying...")
            time.sleep(2)
        except Exception as e:
            print(f"üî¥ Frame sender error: {e}")
            time.sleep(2)

def listen_backchannel():
    global WIDTH, HEIGHT, LASTEVENT
    while not stop_event.is_set():
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(1)  # Shorter timeout for better responsiveness
                s.connect((HOST, BACKCHANNEL_PORT))
                print("üü¢ Backchannel connected")
                
                s.settimeout(0.1)  # Non-blocking reads with short timeout
                buffer = ""
                
                while not stop_event.is_set():
                    try:
                        data = s.recv(1024).decode('utf-8')
                        if not data:  # Connection closed
                            print("üî¥ Backchannel connection closed by server")
                            break
                        
                        buffer += data
                        while '\n' in buffer:
                            line, buffer = buffer.split('\n', 1)
                            line = line.strip()
                            if line:
                                # print(f"üí¨ From C#: {line}")
                                
                                if line == "exit":
                                    print("üî¥ Exiting backchannel listener")
                                    return
                                
                                if line.startswith("NewRes"):
                                    try:
                                        _, width, height = line.split()
                                        WIDTH, HEIGHT = int(width), int(height)
                                        LASTEVENT = {"event": "resize", "width": WIDTH, "height": HEIGHT}
                                        print(f"üîÑ New resolution: {WIDTH}x{HEIGHT}")
                                    except ValueError as e:
                                        print(f"üî¥ Error parsing resolution: {e}")
                                
                                # Send keep-alive response
                                try:
                                    s.send(b"keep-alive\n")
                                except:
                                    break  # Connection lost
                    
                    except socket.timeout:
                        # Send periodic keep-alive
                        try:
                            s.send(b"keep-alive\n")
                        except:
                            break  # Connection lost
                        continue
                    except Exception as e:
                        print(f"üî¥ Backchannel read error: {e}")
                        break
                        
        except (socket.timeout, ConnectionRefusedError) as e:
            if stop_event.is_set():
                break
            print(f"üî¥ Backchannel connection error: {e}. Retrying...")
            time.sleep(2)
        except Exception as e:
            print(f"üî¥ Unexpected backchannel error: {e}")
            time.sleep(2)

# Start the background threads when the module is imported
threading.Thread(target=send_frames, daemon=True).start()
threading.Thread(target=listen_backchannel, daemon=True).start()
print("üü¢ SDL socket threads started")